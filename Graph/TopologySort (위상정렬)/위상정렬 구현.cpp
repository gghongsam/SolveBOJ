/*
위상 정렬의 구현 아이디어

먼저 시작하는 정점은 어떻게 알 수 있을까?
- 자신을 가리키는 간선이 없다면 무조건 첫 시작이다.
- indegree가 0이면 자신에게 들어오는 간선이 없다는 것

indegree가 0인 정점을 위상 정렬의 제일 앞에 위치시키자.
여기서는 가상의 정점 A를 넣었다고 해보자.

계속 정렬을 이어서 하려면 어떻게 해야 될까?
- A에서 다른 정점으로 나아가는 간선을 생각해보자.
- 연결된 다른 정점을 B라고 할때, A->B로 가는 간선만 존재한다면?
- 추가적인 제약을 생각할 필요 X
- 그러므로 A정정메서 뻗어나가는 모든 간선을 지운 후, 위상 정렬을 이어나가면 된다.

위의 과정을 계속 반복해주면된다!
*/

// 실제 코드로 짜려면? 

// 모든 간선을 읽으며 indegree 테이블을 채운다.
// indegree가 0인 정점들을 모두 큐에 넣는다.
// 큐에서 정점을 꺼내 위상 정렬 결과에 추가한다.
// 해당 정점으로부터 연결된 모든 정점의 indegree 값을 1 감소시킨다.(이 때 indegree가 0이 되었다면 그 정점을 큐에 추가한다.)
// 큐가 빌 때 까지 3, 4번 과정을 반복한다
// 정리) indegree array가 0이 될때마다 queue에 저장하는 과정을 반복한다


#include <iostream>
using namespace std;

int main()
{
    // 각 정점은 큐에 최대 1번 들어간다.
    // indegree를 감소시키는 연산은 각 간선에 1번 발생한다.
    // 그래프에서의 DFS/BFS는 O(V+E)인것과 마찬가지로 여기도
    // 시간복잡도는 O(V+E)
}

